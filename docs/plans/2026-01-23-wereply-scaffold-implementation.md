# WeReply Scaffold Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use executing-plans to implement this plan task-by-task.

**Goal:** Generate a working Tauri + React + Rust scaffold with DeepSeek-only wiring and platform Agent stubs that compiles and can be extended directly.

**Architecture:** Tauri/React UI + Rust Orchestrator + platform Agents (Windows Python wxauto, macOS Swift/Accessibility) using a JSON-line IPC protocol and DeepSeek API for suggestions.

**Tech Stack:** Tauri 2.x, React 18 + TypeScript, Rust, Python (wxauto), Swift (Accessibility).

---

### Task 0: Sync existing docs into this worktree

**Files:**
- Create: `README.md`, `docs/`, `.env.example`, `.editorconfig`, `.gitignore`, `CONTRIBUTING.md`, `LICENSE`

**Step 1: Copy docs from main worktree**
Run (from repo root in main worktree):
`rsync -a /Volumes/software/cursor/WeReply/ ./` (ensure you are in `.worktrees/scaffold`)
Expected: docs and root files appear in this worktree

---

### Task 1: Create base Tauri React/TS scaffold

**Files:**
- Create: generated by `npm create tauri-app@latest`
- Modify: repo root files as needed

**Step 1: Back up docs before scaffold**
Run: `mkdir -p .backup && rsync -a README.md docs/ .env.example .editorconfig .gitignore CONTRIBUTING.md LICENSE .backup/`
Expected: backup created

**Step 2: Generate scaffold in a temp directory**
Run: `npm create tauri-app@latest .tmp-tauri -- --template react-ts --manager npm --app-name WeReply --package-name wereply`
Expected: new `.tmp-tauri/` with `src/`, `src-tauri/`, `package.json`

**Step 3: Copy scaffold into repo root**
Run: `rsync -a .tmp-tauri/ ./`
Expected: root now includes `package.json`, `src/`, `src-tauri/`

**Step 4: Restore docs from backup**
Run: `rsync -a .backup/ ./`
Expected: README/docs/etc restored

**Step 5: Remove temp/backup directories**
Run: `rm -rf .tmp-tauri .backup`
Expected: temp directories removed

---

### Task 2: Define Rust Orchestrator skeleton + config model (TDD)

**Files:**
- Create: `src-tauri/src/config.rs`
- Modify: `src-tauri/src/main.rs`
- Test: `src-tauri/src/config.rs`

**Step 1: Write failing tests for config defaults**
Add tests in `src-tauri/src/config.rs`:
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn default_config_values() {
        let cfg = Config::default();
        assert_eq!(cfg.deepseek_model, "deepseek-chat");
        assert_eq!(cfg.suggestion_count, 3);
        assert_eq!(cfg.context_max_messages, 10);
        assert_eq!(cfg.context_max_chars, 2000);
        assert_eq!(cfg.poll_interval_ms, 800);
    }
}
```

**Step 2: Run tests to verify failure**
Run: `cd src-tauri && cargo test`
Expected: FAIL (Config not defined)

**Step 3: Implement minimal Config**
Add `Config` struct with defaults in `src-tauri/src/config.rs`.

**Step 4: Re-run tests**
Run: `cd src-tauri && cargo test`
Expected: PASS

---

### Task 3: Define IPC message types (TDD)

**Files:**
- Create: `src-tauri/src/ipc.rs`
- Modify: `src-tauri/src/main.rs`
- Test: `src-tauri/src/ipc.rs`

**Step 1: Write failing test for IPC serialization**
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn serialize_message_new() {
        let msg = IpcMessage::new(
            "message.new",
            serde_json::json!({"chat_id": "c1", "text": "hi"})
        );
        let line = serde_json::to_string(&msg).unwrap();
        assert!(line.contains("\"type\":\"message.new\""));
    }
}
```

**Step 2: Run tests to verify failure**
Run: `cd src-tauri && cargo test`
Expected: FAIL (IpcMessage not defined)

**Step 3: Implement `IpcMessage`**
Define struct with `version`, `type`, `id`, `timestamp`, `payload` and `new()` helper.

**Step 4: Re-run tests**
Run: `cd src-tauri && cargo test`
Expected: PASS

---

### Task 4: DeepSeek request/response builder (TDD)

**Files:**
- Create: `src-tauri/src/deepseek.rs`
- Test: `src-tauri/src/deepseek.rs`

**Step 1: Write failing test for request build**
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn build_request_payload() {
        let req = build_request("hi", 3, "deepseek-chat", 0.7, 1.0);
        assert_eq!(req["model"], "deepseek-chat");
        assert_eq!(req["messages"].as_array().unwrap().len(), 2);
    }
}
```

**Step 2: Run tests to verify failure**
Run: `cd src-tauri && cargo test`
Expected: FAIL (build_request not defined)

**Step 3: Implement minimal request builder**
Return `serde_json::Value` for `/chat/completions`.

**Step 4: Re-run tests**
Run: `cd src-tauri && cargo test`
Expected: PASS

---

### Task 5: Platform Agent stubs and IPC parsing (TDD for parsing only)

**Files:**
- Create: `src-tauri/src/agent.rs`
- Modify: `src-tauri/src/main.rs`
- Test: `src-tauri/src/agent.rs`

**Step 1: Write failing test for parsing inbound line**
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_inbound_line() {
        let line = r#"{"version":"1.0","type":"agent.ready","id":"1","timestamp":1,"payload":{}}"#;
        let msg = parse_line(line).unwrap();
        assert_eq!(msg.r#type, "agent.ready");
    }
}
```

**Step 2: Run tests to verify failure**
Run: `cd src-tauri && cargo test`
Expected: FAIL

**Step 3: Implement minimal parsing**
Use `serde_json` to parse and return `IpcMessage`.

**Step 4: Re-run tests**
Run: `cd src-tauri && cargo test`
Expected: PASS

---

### Task 6: UI skeleton + Tauri commands (no tests, scaffold only)

**Files:**
- Modify: `src-tauri/src/main.rs`
- Modify: `src/App.tsx`
- Modify: `src/main.tsx`

**Step 1: Add Tauri commands signatures**
Expose commands in `main.rs`: `start_listening`, `stop_listening`, `get_status`, `write_suggestion`.

**Step 2: Build minimal UI**
Add status panel + suggestion list + button to trigger `start_listening`.

**Step 3: Manual smoke run**
Run: `npm install && npm run tauri dev`
Expected: app window opens and no runtime errors in console

---

### Task 7: Agent stubs (non-functional placeholders)

**Files:**
- Create: `platform_agents/windows/wxauto_agent.py`
- Create: `platform_agents/windows/requirements.txt`
- Create: `platform_agents/macos/wechat_agent.swift`
- Create: `platform_agents/macos/scripts.applescript`

**Step 1: Stub Windows Agent**
Implement CLI that prints `agent.ready` and echoes received `input.write`.

**Step 2: Stub macOS Agent**
Implement CLI that prints `agent.ready` and returns `PERMISSION_DENIED` for any `input.write`.

**Step 3: Manual smoke run**
Run: `python platform_agents/windows/wxauto_agent.py`
Expected: outputs `agent.ready` JSON line

---

### Task 8: Verify baseline

**Step 1: Run Rust tests**
Run: `cd src-tauri && cargo test`
Expected: PASS

**Step 2: Run frontend build**
Run: `npm run build`
Expected: PASS
