use serde_json::Value;
use std::cmp::Ordering;
use std::path::{Path, PathBuf};

const LIST_ROLES: [&str; 3] = ["AXOutline", "AXTable", "AXList"];
const INPUT_ROLES: [&str; 2] = ["AXTextArea", "AXTextField"];

#[derive(Debug, Clone, PartialEq)]
pub struct AxNode {
    pub role: Option<String>,
    pub title: Option<String>,
    pub value: Option<String>,
    pub frame: Option<AxRectSnapshot>,
    pub enabled: Option<bool>,
    pub focused: Option<bool>,
    pub children: Vec<AxNode>,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct AxRectSnapshot {
    pub x: f64,
    pub y: f64,
    pub width: f64,
    pub height: f64,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct PathStepSpec {
    pub roles: Vec<String>,
    pub index: usize,
    pub title_contains: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct LearnedPaths {
    pub session_list: Vec<PathStepSpec>,
    pub message_list: Vec<PathStepSpec>,
    pub input: Vec<PathStepSpec>,
}

pub fn parse_snapshot(value: &Value) -> Option<AxNode> {
    let obj = value.as_object()?;
    let role = obj
        .get("role")
        .and_then(|item| item.as_str())
        .map(|item| item.to_string());
    let title = obj
        .get("title")
        .and_then(|item| item.as_str())
        .map(|item| item.to_string());
    let value = obj
        .get("value")
        .and_then(|item| item.as_str())
        .map(|item| item.to_string());
    let enabled = obj.get("enabled").and_then(|item| item.as_bool());
    let focused = obj.get("focused").and_then(|item| item.as_bool());
    let frame = obj.get("frame").and_then(parse_frame);
    let mut children = Vec::new();
    if let Some(array) = obj.get("children").and_then(|item| item.as_array()) {
        for child in array {
            if let Some(node) = parse_snapshot(child) {
                children.push(node);
            }
        }
    }
    Some(AxNode {
        role,
        title,
        value,
        frame,
        enabled,
        focused,
        children,
    })
}

pub fn learn_paths(root: &AxNode) -> Result<LearnedPaths, String> {
    let window_frame = root
        .frame
        .ok_or_else(|| "Window frame missing".to_string())?;
    let mut list_candidates = Vec::new();
    let mut input_candidates = Vec::new();
    collect_candidates(root, &Vec::new(), &mut list_candidates, &mut input_candidates);
    if list_candidates.is_empty() {
        return Err("No list candidates found".to_string());
    }
    let session = pick_best_session_list(&window_frame, &list_candidates)
        .ok_or_else(|| "Session list not found".to_string())?;
    let message = pick_best_message_list(&window_frame, &list_candidates)
        .ok_or_else(|| "Message list not found".to_string())?;
    let input = pick_best_input(&input_candidates).ok_or_else(|| "Input not found".to_string())?;
    Ok(LearnedPaths {
        session_list: session.path.clone(),
        message_list: message.path.clone(),
        input: input.path.clone(),
    })
}

pub fn render_static_paths_rs(paths: &LearnedPaths) -> String {
    let mut output = String::new();
    output.push_str("// This file is auto-generated by learn_wechat_ui_paths.\n");
    output.push_str("use super::ax_path::{step, AxPathStep};\n\n");
    output.push_str("pub const SESSION_LIST_PATH_A: &[AxPathStep] = &[\n");
    output.push_str(&render_steps_rs(&paths.session_list));
    output.push_str("];\n\n");
    output.push_str("pub const MESSAGE_LIST_PATH_A: &[AxPathStep] = &[\n");
    output.push_str(&render_steps_rs(&paths.message_list));
    output.push_str("];\n\n");
    output.push_str("pub const INPUT_PATH_A: &[AxPathStep] = &[\n");
    output.push_str(&render_steps_rs(&paths.input));
    output.push_str("];\n\n");
    output.push_str("pub const SESSION_LIST_PATHS: &[&[AxPathStep]] = &[SESSION_LIST_PATH_A];\n");
    output.push_str("pub const MESSAGE_LIST_PATHS: &[&[AxPathStep]] = &[MESSAGE_LIST_PATH_A];\n");
    output.push_str("pub const INPUT_PATHS: &[&[AxPathStep]] = &[INPUT_PATH_A];\n\n");
    output.push_str("pub fn allow_dynamic_scan() -> bool {\n");
    output.push_str("    std::env::var(\"WEREPLY_ALLOW_DYNAMIC_AX_SCAN\")\n");
    output.push_str("        .ok()\n");
    output.push_str("        .as_deref()\n");
    output.push_str("        == Some(\"1\")\n");
    output.push_str("}\n");
    output
}

pub fn render_swift_paths(paths: &LearnedPaths) -> String {
    let mut output = String::new();
    output.push_str("// AUTO-GENERATED UI PATHS START\n");
    output.push_str("private let sessionListPaths: [[AxPathStep]] = [\n");
    output.push_str(&render_steps_swift(&paths.session_list));
    output.push_str("]\n\n");
    output.push_str("private let messageListPaths: [[AxPathStep]] = [\n");
    output.push_str(&render_steps_swift(&paths.message_list));
    output.push_str("]\n\n");
    output.push_str("private let inputPaths: [[AxPathStep]] = [\n");
    output.push_str(&render_steps_swift(&paths.input));
    output.push_str("]\n");
    output.push_str("// AUTO-GENERATED UI PATHS END\n");
    output
}

pub fn write_static_paths_rs(root: &Path, paths: &LearnedPaths) -> Result<PathBuf, String> {
    let path = root
        .join("src-tauri")
        .join("src")
        .join("ui_automation")
        .join("macos")
        .join("static_ui_paths.rs");
    std::fs::write(&path, render_static_paths_rs(paths))
        .map_err(|err| format!("Write static_ui_paths.rs failed: {err}"))?;
    Ok(path)
}

pub fn update_swift_paths(root: &Path, paths: &LearnedPaths) -> Result<PathBuf, String> {
    let path = root
        .join("platform_agents")
        .join("macos")
        .join("wechat_agent.swift");
    let contents = std::fs::read_to_string(&path)
        .map_err(|err| format!("Read wechat_agent.swift failed: {err}"))?;
    let start = "// AUTO-GENERATED UI PATHS START";
    let end = "// AUTO-GENERATED UI PATHS END";
    let start_index = contents
        .find(start)
        .ok_or_else(|| "Missing AUTO-GENERATED start marker".to_string())?;
    let end_index = contents
        .find(end)
        .ok_or_else(|| "Missing AUTO-GENERATED end marker".to_string())?;
    if end_index < start_index {
        return Err("AUTO-GENERATED markers out of order".to_string());
    }
    let mut updated = String::new();
    updated.push_str(&contents[..start_index]);
    updated.push_str(&render_swift_paths(paths));
    updated.push_str(&contents[end_index + end.len()..]);
    std::fs::write(&path, updated)
        .map_err(|err| format!("Write wechat_agent.swift failed: {err}"))?;
    Ok(path)
}

pub fn find_repo_root() -> Result<PathBuf, String> {
    let start = std::env::current_dir().map_err(|err| err.to_string())?;
    for ancestor in start.ancestors() {
        let rust_path = ancestor
            .join("src-tauri")
            .join("src")
            .join("ui_automation")
            .join("macos")
            .join("static_ui_paths.rs");
        let swift_path = ancestor
            .join("platform_agents")
            .join("macos")
            .join("wechat_agent.swift");
        if rust_path.exists() && swift_path.exists() {
            return Ok(ancestor.to_path_buf());
        }
    }
    Err("Repo root not found".to_string())
}

struct ListCandidate<'a> {
    path: Vec<PathStepSpec>,
    node: &'a AxNode,
}

struct InputCandidate<'a> {
    path: Vec<PathStepSpec>,
    node: &'a AxNode,
}

fn collect_candidates<'a>(
    node: &'a AxNode,
    path: &[PathStepSpec],
    list_candidates: &mut Vec<ListCandidate<'a>>,
    input_candidates: &mut Vec<InputCandidate<'a>>,
) {
    if let Some(role) = node.role.as_deref() {
        if LIST_ROLES.contains(&role) {
            list_candidates.push(ListCandidate {
                path: path.to_vec(),
                node,
            });
        }
        if INPUT_ROLES.contains(&role) {
            input_candidates.push(InputCandidate {
                path: path.to_vec(),
                node,
            });
        }
    }
    for (idx, child) in node.children.iter().enumerate() {
        let Some(step) = step_for_child(node, idx) else { continue };
        let mut next_path = path.to_vec();
        next_path.push(step);
        collect_candidates(child, &next_path, list_candidates, input_candidates);
    }
}

fn step_for_child(parent: &AxNode, child_index: usize) -> Option<PathStepSpec> {
    let child = parent.children.get(child_index)?;
    let role = child.role.as_deref()?;
    let roles = role_group(role);
    let mut index = 0usize;
    for (idx, sibling) in parent.children.iter().enumerate() {
        let Some(sibling_role) = sibling.role.as_deref() else { continue };
        if roles.iter().any(|item| item == sibling_role) {
            if idx == child_index {
                break;
            }
            index += 1;
        }
    }
    Some(PathStepSpec {
        roles,
        index,
        title_contains: None,
    })
}

fn role_group(role: &str) -> Vec<String> {
    if LIST_ROLES.contains(&role) {
        return LIST_ROLES.iter().map(|item| item.to_string()).collect();
    }
    if INPUT_ROLES.contains(&role) {
        return INPUT_ROLES.iter().map(|item| item.to_string()).collect();
    }
    vec![role.to_string()]
}

fn render_steps_rs(steps: &[PathStepSpec]) -> String {
    let mut output = String::new();
    for step in steps {
        output.push_str("    step(&[");
        output.push_str(&step.roles.iter().map(|r| format!("\"{r}\"")).collect::<Vec<_>>().join(", "));
        output.push_str("], ");
        output.push_str(&step.index.to_string());
        output.push_str(", ");
        if let Some(value) = &step.title_contains {
            output.push_str(&format!("Some(\"{}\")", value.replace('"', "\\\"")));
        } else {
            output.push_str("None");
        }
        output.push_str("),\n");
    }
    output
}

fn render_steps_swift(steps: &[PathStepSpec]) -> String {
    let mut output = String::new();
    output.push_str("    [\n");
    for step in steps {
        output.push_str("        AxPathStep(roles: [");
        output.push_str(&step.roles.iter().map(|r| format!("\"{r}\"")).collect::<Vec<_>>().join(", "));
        output.push_str("], index: ");
        output.push_str(&step.index.to_string());
        output.push_str(", titleContains: ");
        if let Some(value) = &step.title_contains {
            output.push_str(&format!("\"{}\"", value.replace('"', "\\\"")));
        } else {
            output.push_str("nil");
        }
        output.push_str("),\n");
    }
    output.push_str("    ],\n");
    output
}

fn parse_frame(value: &Value) -> Option<AxRectSnapshot> {
    let obj = value.as_object()?;
    Some(AxRectSnapshot {
        x: obj.get("x")?.as_f64()?,
        y: obj.get("y")?.as_f64()?,
        width: obj.get("width")?.as_f64()?,
        height: obj.get("height")?.as_f64()?,
    })
}

fn pick_best_session_list<'a>(
    window: &AxRectSnapshot,
    candidates: &'a [ListCandidate<'a>],
) -> Option<&'a ListCandidate<'a>> {
    let mut scored = candidates
        .iter()
        .map(|candidate| {
            let titles = collect_session_titles(candidate.node);
            let score = candidate
                .node
                .frame
                .map(|frame| score_session_list(window, &frame, titles.len()))
                .unwrap_or(titles.len() as i64);
            (score, titles.len(), candidate)
        })
        .collect::<Vec<_>>();
    scored.sort_by(|a, b| a.0.cmp(&b.0));
    scored.pop().map(|(_, _, candidate)| candidate)
}

fn pick_best_message_list<'a>(
    window: &AxRectSnapshot,
    candidates: &'a [ListCandidate<'a>],
) -> Option<&'a ListCandidate<'a>> {
    let mut scored = candidates
        .iter()
        .map(|candidate| {
            let titles = collect_message_texts(candidate.node);
            let score = candidate
                .node
                .frame
                .map(|frame| score_message_list(window, &frame, titles.len()))
                .unwrap_or(titles.len() as i64);
            (score, titles.len(), candidate)
        })
        .collect::<Vec<_>>();
    scored.sort_by(|a, b| a.0.cmp(&b.0));
    scored.pop().map(|(_, _, candidate)| candidate)
}

fn pick_best_input<'a>(candidates: &'a [InputCandidate<'a>]) -> Option<&'a InputCandidate<'a>> {
    let mut scored = candidates
        .iter()
        .map(|candidate| {
            let score = candidate
                .node
                .frame
                .map(|frame| score_input(&frame))
                .unwrap_or(candidate.path.len() as f64);
            (score, candidate)
        })
        .collect::<Vec<_>>();
    scored.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap_or(Ordering::Equal));
    scored.pop().map(|(_, candidate)| candidate)
}

fn score_session_list(window: &AxRectSnapshot, frame: &AxRectSnapshot, title_count: usize) -> i64 {
    let mut score = title_count as i64;
    let center_x = frame.x + frame.width / 2.0;
    let window_center_x = window.x + window.width / 2.0;
    if center_x < window_center_x {
        score += 10_000;
    } else {
        score -= 10_000;
    }
    if frame.width <= window.width * 0.45 {
        score += 500;
    }
    score
}

fn score_message_list(window: &AxRectSnapshot, frame: &AxRectSnapshot, row_count: usize) -> i64 {
    let mut score = row_count as i64;
    let center_x = frame.x + frame.width / 2.0;
    let window_center_x = window.x + window.width / 2.0;
    if center_x >= window_center_x {
        score += 10_000;
    } else {
        score -= 10_000;
    }
    if frame.width >= window.width * 0.45 {
        score += 500;
    }
    score
}

fn score_input(frame: &AxRectSnapshot) -> f64 {
    frame.width * frame.height
}

fn collect_session_titles(list: &AxNode) -> Vec<String> {
    let mut titles = Vec::new();
    for row in &list.children {
        let texts = collect_static_texts(row);
        if let Some(title) = pick_session_title(&texts) {
            titles.push(title);
        }
    }
    titles
}

fn collect_message_texts(list: &AxNode) -> Vec<String> {
    let mut texts = Vec::new();
    for row in &list.children {
        let row_texts = collect_static_texts(row);
        if let Some(text) = pick_row_text(&row_texts) {
            texts.push(text);
        }
    }
    texts
}

fn collect_static_texts(node: &AxNode) -> Vec<String> {
    let mut results = Vec::new();
    collect_static_texts_inner(node, &mut results);
    results
}

fn collect_static_texts_inner(node: &AxNode, results: &mut Vec<String>) {
    if node.role.as_deref() == Some("AXStaticText") {
        if let Some(value) = node.value.as_ref().or(node.title.as_ref()) {
            let trimmed = value.trim();
            if !trimmed.is_empty() {
                results.push(trimmed.to_string());
            }
        }
    }
    for child in &node.children {
        collect_static_texts_inner(child, results);
    }
}

fn pick_row_text(texts: &[String]) -> Option<String> {
    texts
        .iter()
        .map(|item| item.trim())
        .filter(|item| !item.is_empty())
        .max_by_key(|item| item.chars().count())
        .map(|item| item.to_string())
}

fn pick_session_title(texts: &[String]) -> Option<String> {
    let mut fallback = None;
    for item in texts {
        let trimmed = item.trim();
        if trimmed.is_empty() {
            continue;
        }
        if fallback.is_none() {
            fallback = Some(trimmed);
        }
        if looks_like_time(trimmed) {
            continue;
        }
        return Some(trimmed.to_string());
    }
    fallback.map(|item| item.to_string())
}

fn looks_like_time(text: &str) -> bool {
    let trimmed = text.trim();
    if is_clock_time(trimmed) {
        return true;
    }
    if is_date(trimmed) {
        return true;
    }
    let upper = trimmed.to_ascii_uppercase();
    upper.ends_with(" AM") || upper.ends_with(" PM") || upper == "AM" || upper == "PM"
}

fn is_clock_time(text: &str) -> bool {
    if text.len() != 5 {
        return false;
    }
    let bytes = text.as_bytes();
    bytes[2] == b':'
        && bytes[0].is_ascii_digit()
        && bytes[1].is_ascii_digit()
        && bytes[3].is_ascii_digit()
        && bytes[4].is_ascii_digit()
}

fn is_date(text: &str) -> bool {
    if text.len() != 10 {
        return false;
    }
    let bytes = text.as_bytes();
    bytes[4] == b'-'
        && bytes[7] == b'-'
        && bytes[..4].iter().all(|b| b.is_ascii_digit())
        && bytes[5..7].iter().all(|b| b.is_ascii_digit())
        && bytes[8..10].iter().all(|b| b.is_ascii_digit())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn learns_paths_from_simple_tree() {
        let tree = AxNode {
            role: Some("AXWindow".to_string()),
            title: Some("WeChat".to_string()),
            value: None,
            frame: Some(AxRectSnapshot {
                x: 0.0,
                y: 0.0,
                width: 1000.0,
                height: 800.0,
            }),
            enabled: None,
            focused: None,
            children: vec![AxNode {
                role: Some("AXSplitGroup".to_string()),
                title: None,
                value: None,
                frame: Some(AxRectSnapshot {
                    x: 0.0,
                    y: 0.0,
                    width: 1000.0,
                    height: 800.0,
                }),
                enabled: None,
                focused: None,
                children: vec![
                    AxNode {
                        role: Some("AXGroup".to_string()),
                        title: None,
                        value: None,
                        frame: Some(AxRectSnapshot {
                            x: 0.0,
                            y: 0.0,
                            width: 280.0,
                            height: 800.0,
                        }),
                        enabled: None,
                        focused: None,
                        children: vec![AxNode {
                            role: Some("AXOutline".to_string()),
                            title: None,
                            value: None,
                            frame: Some(AxRectSnapshot {
                                x: 0.0,
                                y: 0.0,
                                width: 280.0,
                                height: 800.0,
                            }),
                            enabled: None,
                            focused: None,
                            children: vec![AxNode {
                                role: Some("AXGroup".to_string()),
                                title: None,
                                value: None,
                                frame: None,
                                enabled: None,
                                focused: None,
                                children: vec![AxNode {
                                    role: Some("AXStaticText".to_string()),
                                    title: None,
                                    value: Some("Alice".to_string()),
                                    frame: None,
                                    enabled: None,
                                    focused: None,
                                    children: vec![],
                                }],
                            }],
                        }],
                    },
                    AxNode {
                        role: Some("AXGroup".to_string()),
                        title: None,
                        value: None,
                        frame: Some(AxRectSnapshot {
                            x: 300.0,
                            y: 0.0,
                            width: 700.0,
                            height: 800.0,
                        }),
                        enabled: None,
                        focused: None,
                        children: vec![
                            AxNode {
                                role: Some("AXList".to_string()),
                                title: None,
                                value: None,
                                frame: Some(AxRectSnapshot {
                                    x: 300.0,
                                    y: 200.0,
                                    width: 700.0,
                                    height: 400.0,
                                }),
                                enabled: None,
                                focused: None,
                                children: vec![AxNode {
                                    role: Some("AXGroup".to_string()),
                                    title: None,
                                    value: None,
                                    frame: None,
                                    enabled: None,
                                    focused: None,
                                    children: vec![AxNode {
                                        role: Some("AXStaticText".to_string()),
                                        title: None,
                                        value: Some("Hello".to_string()),
                                        frame: None,
                                        enabled: None,
                                        focused: None,
                                        children: vec![],
                                    }],
                                }],
                            },
                            AxNode {
                                role: Some("AXTextArea".to_string()),
                                title: None,
                                value: None,
                                frame: Some(AxRectSnapshot {
                                    x: 300.0,
                                    y: 10.0,
                                    width: 700.0,
                                    height: 120.0,
                                }),
                                enabled: None,
                                focused: None,
                                children: vec![],
                            },
                        ],
                    },
                ],
            }],
        };
        let learned = learn_paths(&tree).expect("should learn paths");
        assert!(!learned.session_list.is_empty());
        assert!(!learned.message_list.is_empty());
        assert!(!learned.input.is_empty());
        assert_eq!(learned.session_list[0].roles, vec!["AXSplitGroup".to_string()]);
    }
}
